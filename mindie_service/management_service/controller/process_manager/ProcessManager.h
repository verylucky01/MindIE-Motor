/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2024-2025. All rights reserved.
 * MindIE is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *         http://license.coscl.org.cn/MulanPSL2
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
#ifndef MINDIE_MS_CONTROLLER_PROCESS_MANAGER_H
#define MINDIE_MS_CONTROLLER_PROCESS_MANAGER_H
#include <atomic>
#include <mutex>
#include <memory>
#include <condition_variable>
#include <thread>
#include <nlohmann/json.hpp>
#include <sys/types.h>
#include "Logger.h"
#include "NodeStatus.h"
namespace MINDIE::MS {

struct GroupInfo {
    std::map<uint64_t, std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> groups;
    std::map<uint64_t, std::vector<uint64_t>> flexGroups;
};
/// The manager of the controller process.
///
/// This class outputs the controller's process information to a file and loads the file when the controller restarts.
/// The process information includes the server's role, group ID, etc.
class ProcessManager {
public:
    /// Get the instance of the ProcessManager class.
    ///
    /// \return The reference to the object.
    static ProcessManager *GetInstance()
    {
        static ProcessManager singleton;
        return &singleton;
    }

    /// Initialize the ProcessManager object.
    ///
    /// If the to_file config of process_manager is false, the function ends directly.
    /// If the to_file config of process_manager is true, a thread will be created. This allows the ProcessManager
    /// object to periodically output the server information in the format of a JSON file.
    /// \param nodeStatus The shared pointer of nodeStatus which is globally managed in the controller.
    /// \return The result of the initialization. 0 indicates success. -1 indicates failure.
    int32_t Init(const std::shared_ptr<NodeStatus> &nodeStatus);

    /// Stop the thread that is created using the Init method.
    void Stop();

    /// Read the process file.
    ///
    /// Read and validate the process file if the to_file config of process_manager is true.
    /// \return The contents of the process file.
    nlohmann::json LoadProcessFile() const;

    /// Update the server information according to the process file.
    ///
    /// Update the group ID, total slot number, and total block number of the Server.
    /// It is used only in pd_separate mode.
    /// \return The result of the updating. 0 indicates success. -1 indicates failure.
    int32_t GetStatusFromPath(const nlohmann::json &statusJson,
        std::vector<std::unique_ptr<NodeInfo>> &servers, std::vector<std::unique_ptr<NodeInfo>> &availableServers,
        std::vector<std::unique_ptr<NodeInfo>> &faultyServers,
        GroupInfo &groupInfo) const;

    /// Get the node information according to the process file.
    ///
    /// get the node information and save it to the availableServers vector.
    /// \return The result of the get. 0 indicates success. -1 indicates failure.
    int32_t GetNodeInfoFromPath(const nlohmann::json &statusJson,
        std::vector<std::unique_ptr<NodeInfo>> &servers,
        std::vector<std::unique_ptr<NodeInfo>> &availableServers,
        std::map<uint64_t, std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> &groups,
        std::map<uint64_t, std::vector<uint64_t>> &flexGroups) const;

    /// Generate process information.
    ///
    /// Obtain the server information from the nodeStatus. This method exports the server's role,
    /// group ID, total slot number, total block number, etc. as a JSON object.
    /// \param nodeStatus The shared pointer of nodeStatus which is globally managed in the controller.
    /// \return The JSON object that saves the information of the server cluster.
    nlohmann::json GenerateClusterInfo(const std::shared_ptr<NodeStatus> &nodeStatus) const;

    /// Generate process information.
    ///
    /// Obtain the server information from the vector. This method exports the server's role,
    /// group ID, total slot number, total block number, etc. as a JSON object.
    /// \param servers The vector of servers.
    /// \return The JSON object that saves the information of the server cluster.
    nlohmann::json GenerateClusterInfoByList(const std::vector<std::unique_ptr<NodeInfo>> &servers) const;

    /// Save process information generated by server list to file.
    ///
    /// \return The result of saving files. 0 indicates success. -1 indicates failure.
    int32_t SaveServerListToFile(const std::vector<std::unique_ptr<NodeInfo>> &servers) const;

    /// Update the server information according to the process file.
    ///
    /// Update the total slot number and total block number of the server.
    /// It is used only in single_node mode.
    /// \return The result of the updating. 0 indicates success. -1 indicates failure.
    int32_t GetTotalAvailableResource(const nlohmann::json &statusJson,
        std::vector<std::unique_ptr<NodeInfo>> &servers,
        std::vector<std::unique_ptr<NodeInfo>> &availableServers) const;

    // Recover instance start id (g_startIdNumber)
    void RecoverInstanceStartIdNumber(const nlohmann::json &statusJson) const;

    ProcessManager() = default;

    /// Destructor.
    ///
    /// This destructor call the Stop method to stop the thread.
    ~ProcessManager()
    {
        Stop();
    };
    ProcessManager(const ProcessManager &obj) = delete;
    ProcessManager &operator=(const ProcessManager &obj) = delete;
    ProcessManager(ProcessManager &&obj) = delete;
    ProcessManager &operator=(ProcessManager &&obj) = delete;
private:

    /// Save process information generated by nodeStatus to file.
    ///
    /// \return The result of saving files. 0 indicates success. -1 indicates failure.
    int32_t SaveStatusToFile(const std::shared_ptr<NodeStatus> &nodeStatus) const;
    void RemoveInvalidGroups(std::map<uint64_t, std::vector<uint64_t>> &flexGroup,
        std::map<uint64_t, std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> &nodesInGroup) const;
    int32_t ResizeGroups(const nlohmann::json &nodes,
        std::map<uint64_t, std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> &groups,
        std::map<uint64_t, std::vector<uint64_t>> &flexGroup,
        const std::map<std::string, uint32_t> &ipToIndex, std::vector<std::unique_ptr<NodeInfo>> &servers) const;
    void GenerateSingleNodesInfo(nlohmann::json &nodesJson, const NodeInfo &nodeInfo, bool isFaulty) const;
    int32_t RecoverGroups(const nlohmann::json &nodes,
        std::map<uint64_t, std::pair<std::vector<uint64_t>, std::vector<uint64_t>>> &groups,
        std::map<uint64_t, std::vector<uint64_t>> &flexGroup,
        const std::map<std::pair<std::string, std::string>, uint32_t> &ipToIndex) const;
    void Wait();
    std::atomic<bool> mRun = { true };                   /// The running flag of the while loop in the thread.
    std::atomic<uint32_t> mWaitSeconds = { 0 };          /// The time interval for executing the SaveStatusToFile.
    std::unique_ptr<std::thread> mMainThread = nullptr;  /// The thread that dumps process information to a JSON file.
};

}
#endif // MINDIE_MS_CONTROLLER_PROCESS_MANAGER_H
